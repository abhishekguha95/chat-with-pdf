// schema.prisma
generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["postgresqlExtensions"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Enable pgvector via migration SQL: CREATE EXTENSION IF NOT EXISTS vector;

// Projects own files and chunks
model Project {
    id          String   @id @default(uuid())
    title       String   @db.VarChar(255)
    description String
    status      String   @default("creating") @db.VarChar(50) // creating|failed|ready, etc.
    createdAt   DateTime @default(now()) @map("created_at")
    updatedAt   DateTime @updatedAt @map("updated_at")

    files  File[]
    chunks Chunk[] // denormalized read model for retrieval

    @@map("projects")
}

// Unified file/document metadata
model File {
    id               String   @id @default(uuid())
    projectId        String   @map("project_id")
    // names + storage
    filename         String   @db.VarChar(255)
    url              String   @db.VarChar(500) // S3/MinIO path
    mimeType         String?  @map("mime_type") @db.VarChar(100)
    fileSize         Int?     @map("file_size")
    // lifecycle
    uploadStatus     String   @default("pending") @map("upload_status") @db.VarChar(50) // pending|uploaded|failed
    processingStatus String   @default("pending") @map("processing_status") @db.VarChar(50) // pending|processing|completed|failed
    // provenance and extra
    metadata         Json?
    createdAt        DateTime @default(now()) @map("created_at")
    updatedAt        DateTime @updatedAt @map("updated_at")

    project       Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
    chunks        Chunk[]
    ProcessingJob ProcessingJob[]

    @@index([projectId])
    @@map("files")
}

// Unified chunk + embedding row for retrieval and lineage
model Chunk {
    id         String                      @id @default(uuid())
    projectId  String                      @map("project_id")
    fileId     String                      @map("file_id")
    // content + vector
    content    String                      @db.Text
    vector     Unsupported("vector(384)")? // MiniLM all-MiniLM-L6-v2 default; make nullable for staged ingest
    // positioning
    chunkIndex Int?                        @map("chunk_index")
    pageNumber Int?                        @map("page_number")
    charStart  Int?                        @map("char_start")
    charEnd    Int?                        @map("char_end")
    // filters and provenance
    metadata   Json?
    createdAt  DateTime                    @default(now()) @map("created_at")
    updatedAt  DateTime                    @updatedAt @map("updated_at")

    project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
    file    File    @relation(fields: [fileId], references: [id], onDelete: Cascade)

    @@index([projectId])
    @@index([fileId])
    // If you plan ANN, also add a SQL migration to create IVFFlat/HNSW index on vector
    @@map("chunks")
}

// Optional lightweight async job tracker for PoC
model ProcessingJob {
    id           String    @id @default(uuid())
    fileId       String    @map("file_id")
    jobId        String    @unique @map("job_id") @db.VarChar(100)
    status       String    @default("pending") @db.VarChar(50) // pending|running|completed|failed
    errorMessage String?   @map("error_message") @db.Text
    progress     Float     @default(0.0)
    startedAt    DateTime? @map("started_at")
    completedAt  DateTime? @map("completed_at")
    createdAt    DateTime  @default(now()) @map("created_at")

    file File @relation(fields: [fileId], references: [id], onDelete: Cascade)

    @@index([fileId])
    @@map("processing_jobs")
}
